

# 电网集团发票识别助手 — 开发设计文档

---

## 一、项目背景与目标

### 1.1 痛点分析

| 痛点 | 现状 | 目标 |
|------|------|------|
| 发票量大、手工录入慢 | 每月数百张发票，人工逐字段录入 ERP/财务系统 | OCR 一键识别，秒级提取全部字段 |
| 多系统切换繁琐 | 需登录 ERP、报销系统、税务系统等多个平台 | 统一入口，自动登录并填写 |
| 流转审批链路长 | 纸质/邮件流转，状态不透明 | 本地发起 → 自动提交 → 状态追踪 |
| 发票合规校验靠人眼 | 税号、金额、日期等易出错 | 自动校验 + 风险提示 |
| 部署受限 | 集团内网环境，不允许随意部署云服务 | 打包为本地桌面程序，开箱即用 |

### 1.2 项目定位

一款面向电网集团财务/行政人员的本地桌面工具，核心能力：

1. 拍照/扫描/PDF → OCR 识别 → 结构化发票数据
2. 通过无头浏览器自动登录集团内部系统，完成字段填写、提交、流转
3. 发票台账管理 + 状态追踪
4. 打包为 Windows 本地可执行程序（.exe），无需安装额外运行环境

---

## 二、整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    Electron 桌面壳                        │
│  ┌───────────────┐  ┌────────────────┐  ┌─────────────┐ │
│  │  Vue 3 前端    │  │  Node 主进程    │  │ 本地 SQLite │ │
│  │  (Renderer)   │  │  (Main)        │  │   数据库     │ │
│  └───────┬───────┘  └───────┬────────┘  └──────┬──────┘ │
│          │ IPC              │                   │        │
│          ▼                  ▼                   │        │
│  ┌───────────────┐  ┌────────────────┐         │        │
│  │  发票预览/编辑 │  │ Playwright     │         │        │
│  │  台账/状态面板 │  │ 无头浏览器引擎  │         │        │
│  └───────────────┘  │ (自动登录/填写) │         │        │
│                     └───────┬────────┘         │        │
│                             │                   │        │
│                     ┌───────▼────────┐         │        │
│                     │  GLM-4V-Flash  │         │        │
│                     │  OCR 识别服务   │◄────────┘        │
│                     │ (API / 本地推理)│                   │
│                     └────────────────┘                   │
└─────────────────────────────────────────────────────────┘
```

### 2.1 技术选型理由

| 层级 | 技术 | 理由 |
|------|------|------|
| 桌面壳 | Electron 28+ | 成熟稳定，集团 Windows 环境兼容好，打包方便 |
| 前端 | Vue 3 + Vite + Element Plus | 轻量、开发效率高、组件丰富 |
| OCR 引擎 | 智谱 GLM-4V-Flash API | 多模态大模型，发票识别准确率高，支持结构化输出 |
| 备用 OCR | PaddleOCR 本地推理 | 离线场景兜底，无需外网 |
| 自动化 | Playwright (Chromium) | 比 Puppeteer 更稳定，支持多浏览器，API 更友好 |
| 本地存储 | better-sqlite3 | 零配置、嵌入式、性能好 |
| 打包 | electron-builder | 支持 NSIS 安装包、免安装便携包 |

---

## 三、核心模块详细设计

### 3.1 模块总览

```
src/
├── main/                    # Electron 主进程
│   ├── index.ts             # 入口
│   ├── ipc/                 # IPC 通信处理
│   ├── ocr/                 # OCR 识别模块
│   │   ├── glm-ocr.ts       # GLM-4V API 调用
│   │   └── paddle-ocr.ts    # PaddleOCR 本地兜底
│   ├── automation/          # 无头浏览器自动化
│   │   ├── browser-pool.ts  # 浏览器实例管理
│   │   ├── login-manager.ts # 多系统登录管理
│   │   └── scripts/         # 各系统填写脚本
│   │       ├── erp-fill.ts
│   │       ├── reimburse-fill.ts
│   │       └── tax-fill.ts
│   ├── db/                  # 数据库
│   │   ├── schema.ts
│   │   └── invoice-dao.ts
│   └── utils/
│       ├── crypto.ts        # 凭据加密
│       └── validator.ts     # 发票校验规则
├── renderer/                # Vue 前端
│   ├── views/
│   │   ├── InvoiceScan.vue  # 扫描/上传页
│   │   ├── InvoiceList.vue  # 台账列表
│   │   ├── InvoiceDetail.vue# 详情/编辑
│   │   ├── AutoFill.vue     # 自动填写控制台
│   │   └── Settings.vue     # 系统配置
│   ├── components/
│   └── stores/
├── shared/                  # 共享类型定义
│   └── types.ts
└── resources/               # 静态资源/模型文件
```

---

### 3.2 OCR 识别模块

#### 3.2.1 GLM-4V-Flash 调用方案

```typescript
// src/main/ocr/glm-ocr.ts

import fs from 'fs'
import path from 'path'

interface InvoiceField {
  invoiceCode: string        // 发票代码
  invoiceNumber: string      // 发票号码
  invoiceDate: string        // 开票日期
  checkCode: string          // 校验码
  buyerName: string          // 购买方名称
  buyerTaxId: string         // 购买方税号
  sellerName: string         // 销售方名称
  sellerTaxId: string        // 销售方税号
  totalAmount: number        // 合计金额
  taxAmount: number          // 税额
  totalWithTax: number       // 价税合计
  invoiceType: string        // 发票类型
  items: InvoiceItem[]       // 明细行
  confidence: number         // 整体置信度
}

interface InvoiceItem {
  name: string               // 货物/服务名称
  specification: string      // 规格型号
  unit: string               // 单位
  quantity: number            // 数量
  unitPrice: number           // 单价
  amount: number              // 金额
  taxRate: string             // 税率
  tax: number                 // 税额
}

const SYSTEM_PROMPT = `你是电网集团发票识别专家。请从图片中精确提取发票的所有字段信息，
以严格的 JSON 格式返回。注意：
1. 金额字段返回数字类型，保留两位小数
2. 日期格式统一为 YYYY-MM-DD
3. 如果某字段无法识别，返回空字符串或 0
4. confidence 字段为 0-1 之间的浮点数，表示整体识别置信度
5. 特别注意区分"增值税专用发票"和"增值税普通发票"
6. 电力行业常见项目：电费、电力工程服务、电力设备等，请准确识别`

export async function recognizeInvoice(imagePath: string): Promise<InvoiceField> {
  const imageBuffer = fs.readFileSync(imagePath)
  const base64Image = imageBuffer.toString('base64')
  const ext = path.extname(imagePath).slice(1)
  const mimeType = ext === 'png' ? 'image/png' : 'image/jpeg'

  const response = await fetch('https://open.bigmodel.cn/api/paas/v4/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getApiKey()}`
    },
    body: JSON.stringify({
      model: 'glm-4v-flash',
      messages: [
        {
          role: 'system',
          content: SYSTEM_PROMPT
        },
        {
          role: 'user',
          content: [
            {
              type: 'image_url',
              image_url: { url: `data:${mimeType};base64,${base64Image}` }
            },
            {
              type: 'text',
              text: '请识别这张发票的全部信息，以 JSON 格式返回。'
            }
          ]
        }
      ],
      temperature: 0.1,  // 低温度保证稳定输出
      max_tokens: 2000
    })
  })

  const data = await response.json()
  const content = data.choices[0].message.content

  // 提取 JSON（兼容 markdown code block 包裹的情况）
  const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/) || [null, content]
  const result: InvoiceField = JSON.parse(jsonMatch[1] || content)

  return result
}

function getApiKey(): string {
  // 从加密的本地配置中读取
  const { getDecryptedConfig } = require('../utils/crypto')
  return getDecryptedConfig('glm_api_key')
}
```

#### 3.2.2 PaddleOCR 离线兜底

```typescript
// src/main/ocr/paddle-ocr.ts
// 用于内网完全断网场景

import { execFile } from 'child_process'
import path from 'path'

export async function recognizeOffline(imagePath: string): Promise<string[][]> {
  const ppOcrBin = path.join(process.resourcesPath, 'paddleocr', 'ppocr.exe')

  return new Promise((resolve, reject) => {
    execFile(ppOcrBin, ['--image_path', imagePath, '--output_format', 'json'], 
      { timeout: 30000 },
      (error, stdout) => {
        if (error) return reject(error)
        const raw = JSON.parse(stdout)
        // 返回 [[文本, 置信度], ...] 格式
        resolve(raw.results.map((r: any) => [r.text, r.confidence]))
      }
    )
  })
}
```

#### 3.2.3 识别策略调度

```typescript
// src/main/ocr/index.ts

import { recognizeInvoice } from './glm-ocr'
import { recognizeOffline } from './paddle-ocr'

export async function smartRecognize(imagePath: string, config: AppConfig) {
  // 优先使用 GLM-4V
  if (config.ocrMode === 'glm' || config.ocrMode === 'auto') {
    try {
      const result = await recognizeInvoice(imagePath)
      if (result.confidence > 0.85) return { source: 'glm', data: result }
    } catch (e) {
      console.warn('GLM OCR 失败，降级到 PaddleOCR', e)
    }
  }

  // 降级到本地 PaddleOCR + 规则解析
  const rawTexts = await recognizeOffline(imagePath)
  const parsed = parseInvoiceFromRawText(rawTexts)
  return { source: 'paddle', data: parsed }
}
```

---

### 3.3 发票智能校验模块

```typescript
// src/main/utils/validator.ts

interface ValidationResult {
  valid: boolean
  errors: ValidationError[]
  warnings: ValidationWarning[]
}

interface ValidationError {
  field: string
  message: string
  severity: 'error' | 'warning'
}

// 电网集团专用校验规则
const POWER_GRID_TAX_IDS = [
  '91110000100000XXXX',  // 国家电网
  '91440300100000XXXX',  // 南方电网
  // ... 各省市电力公司税号
]

export function validateInvoice(invoice: InvoiceField): ValidationResult {
  const errors: ValidationError[] = []
  const warnings: ValidationWarning[] = []

  // 1. 基础字段完整性
  const requiredFields = ['invoiceCode', 'invoiceNumber', 'invoiceDate', 
                          'buyerTaxId', 'sellerTaxId', 'totalWithTax']
  for (const field of requiredFields) {
    if (!invoice[field]) {
      errors.push({ field, message: `${field} 不能为空`, severity: 'error' })
    }
  }

  // 2. 税号格式校验（15/18/20位）
  const taxIdPattern = /^[0-9A-Z]{15,20}$/
  if (invoice.buyerTaxId && !taxIdPattern.test(invoice.buyerTaxId)) {
    errors.push({ field: 'buyerTaxId', message: '购买方税号格式异常', severity: 'error' })
  }

  // 3. 金额勾稽关系校验
  const calculatedTotal = Number((invoice.totalAmount + invoice.taxAmount).toFixed(2))
  if (Math.abs(calculatedTotal - invoice.totalWithTax) > 0.01) {
    errors.push({
      field: 'totalWithTax',
      message: `金额勾稽不平：${invoice.totalAmount} + ${invoice.taxAmount} ≠ ${invoice.totalWithTax}`,
      severity: 'error'
    })
  }

  // 4. 明细行合计校验
  if (invoice.items.length > 0) {
    const itemsTotal = invoice.items.reduce((sum, item) => sum + item.amount, 0)
    if (Math.abs(itemsTotal - invoice.totalAmount) > 0.01) {
      warnings.push({
        field: 'items',
        message: '明细行金额合计与发票金额不一致，请人工复核',
        severity: 'warning'
      })
    }
  }

  // 5. 日期合理性（不能是未来日期，不能超过1年）
  const invoiceDate = new Date(invoice.invoiceDate)
  const now = new Date()
  if (invoiceDate > now) {
    errors.push({ field: 'invoiceDate', message: '开票日期不能晚于当前日期', severity: 'error' })
  }
  const oneYearAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate())
  if (invoiceDate < oneYearAgo) {
    warnings.push({ field: 'invoiceDate', message: '发票已超过一年，请确认是否可报销', severity: 'warning' })
  }

  // 6. 购买方是否为集团内部单位
  if (!POWER_GRID_TAX_IDS.some(id => invoice.buyerTaxId?.startsWith(id.slice(0, 8)))) {
    warnings.push({
      field: 'buyerTaxId',
      message: '购买方非集团内部单位，请确认',
      severity: 'warning'
    })
  }

  // 7. 重复发票检测（需查库）
  // 这部分在调用层处理

  return {
    valid: errors.filter(e => e.severity === 'error').length === 0,
    errors,
    warnings
  }
}
```

---

### 3.4 无头浏览器自动化模块

#### 3.4.1 浏览器池管理

```typescript
// src/main/automation/browser-pool.ts

import { chromium, Browser, BrowserContext, Page } from 'playwright'
import path from 'path'

class BrowserPool {
  private browser: Browser | null = null
  private contexts: Map<string, BrowserContext> = new Map()

  async init() {
    // 使用 Electron 内置的 Chromium 或独立 Chromium
    const chromiumPath = this.getChromiumPath()
    this.browser = await chromium.launch({
      executablePath: chromiumPath,
      headless: true,           // 默认无头
      args: [
        '--no-sandbox',
        '--disable-gpu',
        '--disable-dev-shm-usage',
        '--ignore-certificate-errors'  // 集团内部系统常用自签证书
      ]
    })
  }

  async getContext(systemId: string): Promise<BrowserContext> {
    if (this.contexts.has(systemId)) {
      return this.contexts.get(systemId)!
    }

    const context = await this.browser!.newContext({
      // 持久化 cookie，避免重复登录
      storageState: this.getStorageStatePath(systemId),
      viewport: { width: 1920, height: 1080 },
      ignoreHTTPSErrors: true
    })

    this.contexts.set(systemId, context)
    return context
  }

  async newPage(systemId: string): Promise<Page> {
    const context = await this.getContext(systemId)
    return context.newPage()
  }

  // 保存登录状态
  async saveSession(systemId: string) {
    const context = this.contexts.get(systemId)
    if (context) {
      const statePath = this.getStorageStatePath(systemId)
      await context.storageState({ path: statePath })
    }
  }

  private getChromiumPath(): string {
    if (process.platform === 'win32') {
      return path.join(process.resourcesPath, 'chromium', 'chrome.exe')
    }
    return ''
  }

  private getStorageStatePath(systemId: string): string {
    const { app } = require('electron')
    return path.join(app.getPath('userData'), 'sessions', `${systemId}.json`)
  }

  async destroy() {
    for (const [id, ctx] of this.contexts) {
      await this.saveSession(id)
      await ctx.close()
    }
    await this.browser?.close()
  }
}

export const browserPool = new BrowserPool()
```

#### 3.4.2 多系统登录管理

```typescript
// src/main/automation/login-manager.ts

import { Page } from 'playwright'
import { browserPool } from './browser-pool'
import { getDecryptedCredential } from '../utils/crypto'

interface SystemConfig {
  id: string
  name: string
  loginUrl: string
  type: 'erp' | 'reimburse' | 'tax' | 'custom'
  loginStrategy: 'form' | 'sso' | 'cas'  // 登录方式
}

// 集团常见系统配置
const SYSTEMS: SystemConfig[] = [
  {
    id: 'erp_sap',
    name: 'SAP ERP',
    loginUrl: 'https://erp.internal.sgcc.com.cn/login',
    type: 'erp',
    loginStrategy: 'form'
  },
  {
    id: 'reimburse',
    name: '费用报销系统',
    loginUrl: 'https://expense.internal.sgcc.com.cn/',
    type: 'reimburse',
    loginStrategy: 'cas'
  },
  {
    id: 'tax_platform',
    name: '税务管理平台',
    loginUrl: 'https://tax.internal.sgcc.com.cn/',
    type: 'tax',
    loginStrategy: 'sso'
  }
]

export class LoginManager {

  // 统一登录入口
  async login(systemId: string): Promise<Page> {
    const system = SYSTEMS.find(s => s.id === systemId)
    if (!system) throw new Error(`未知系统: ${systemId}`)

    const page = await browserPool.newPage(systemId)

    // 先尝试直接访问（可能 session 还有效）
    await page.goto(system.loginUrl, { waitUntil: 'networkidle', timeout: 15000 })

    const needLogin = await this.checkNeedLogin(page, system)
    if (needLogin) {
      const credentials = await getDecryptedCredential(systemId)
      await this.performLogin(page, system, credentials)
      await browserPool.saveSession(systemId)
    }

    return page
  }

  private async checkNeedLogin(page: Page, system: SystemConfig): Promise<boolean> {
    // 检查是否在登录页面
    const url = page.url()
    return url.includes('login') || url.includes('cas') || url.includes('sso')
  }

  private async performLogin(
    page: Page, 
    system: SystemConfig, 
    credentials: { username: string; password: string }
  ) {
    switch (system.loginStrategy) {
      case 'form':
        await this.formLogin(page, credentials)
        break
      case 'cas':
        await this.casLogin(page, credentials)
        break
      case 'sso':
        await this.ssoLogin(page, credentials)
        break
    }

    // 等待登录完成
    await page.waitForNavigation({ waitUntil: 'networkidle', timeout: 20000 })
  }

  private async formLogin(page: Page, cred: { username: string; password: string }) {
    // 通用表单登录 — 自动探测输入框
    const usernameSelector = await this.findSelector(page, [
      'input[name="username"]', 'input[name="user"]', 
      'input[name="loginName"]', '#username', '#user'
    ])
    const passwordSelector = await this.findSelector(page, [
      'input[name="password"]', 'input[name="pwd"]',
      'input[type="password"]', '#password'
    ])

    await page.fill(usernameSelector, cred.username)
    await page.fill(passwordSelector, cred.password)

    // 点击登录按钮
    const submitSelector = await this.findSelector(page, [
      'button[type="submit"]', 'input[type="submit"]',
      '.login-btn', '#loginBtn', 'button:has-text("登录")'
    ])
    await page.click(submitSelector)
  }

  private async casLogin(page: Page, cred: { username: string; password: string }) {
    // CAS 统一认证登录
    await page.fill('#username', cred.username)
    await page.fill('#password', cred.password)
    await page.click('.btn-submit, button[type="submit"]')
  }

  private async ssoLogin(page: Page, cred: { username: string; password: string }) {
    // SSO 单点登录
    await page.fill('input[name="username"]', cred.username)
    await page.fill('input[name="password"]', cred.password)
    await page.click('#loginButton, .sso-login-btn')
  }

  private async findSelector(page: Page, candidates: string[]): Promise<string> {
    for (const selector of candidates) {
      const el = await page.$(selector)
      if (el) return selector
    }
    throw new Error(`无法找到匹配的元素: ${candidates.join(', ')}`)
  }
}

export const loginManager = new LoginManager()
```

#### 3.4.3 ERP 自动填写脚本示例

```typescript
// src/main/automation/scripts/erp-fill.ts

import { Page } from 'playwright'
import { InvoiceField } from '../../shared/types'
import { loginManager } from '../login-manager'

export async function fillErpInvoice(invoice: InvoiceField): Promise<FillResult> {
  const page = await loginManager.login('erp_sap')

  try {
    // 1. 导航到发票录入页面
    await page.goto('https://erp.internal.sgcc.com.cn/invoice/create', {
      waitUntil: 'networkidle'
    })

    // 2. 选择发票类型
    await page.selectOption('#invoiceType', invoice.invoiceType === '增值税专用发票' 
      ? 'special' : 'normal')

    // 3. 填写发票头信息
    await page.fill('#invoiceCode', invoice.invoiceCode)
    await page.fill('#invoiceNumber', invoice.invoiceNumber)
    await page.fill('#invoiceDate', invoice.invoiceDate)
    await page.fill('#checkCode', invoice.checkCode)

    // 4. 填写购销方信息
    await page.fill('#buyerName', invoice.buyerName)
    await page.fill('#buyerTaxId', invoice.buyerTaxId)
    await page.fill('#sellerName', invoice.sellerName)
    await page.fill('#sellerTaxId', invoice.sellerTaxId)

    // 5. 填写金额
    await page.fill('#totalAmount', String(invoice.totalAmount))
    await page.fill('#taxAmount', String(invoice.taxAmount))
    await page.fill('#totalWithTax', String(invoice.totalWithTax))

    // 6. 填写明细行
    for (let i = 0; i < invoice.items.length; i++) {
      if (i > 0) {
        await page.click('#addItemRow')  // 新增行
        await page.waitForTimeout(500)
      }
      const item = invoice.items[i]
      const rowPrefix = `#item_${i}`
      await page.fill(`${rowPrefix}_name`, item.name)
      await page.fill(`${rowPrefix}_spec`, item.specification)
      await page.fill(`${rowPrefix}_unit`, item.unit)
      await page.fill(`${rowPrefix}_qty`, String(item.quantity))
      await page.fill(`${rowPrefix}_price`, String(item.unitPrice))
      await page.fill(`${rowPrefix}_amount`, String(item.amount))
    }

    // 7. 截图留证
    const screenshot = await page.screenshot({ fullPage: true })

    // 8. 提交（可配置为仅保存草稿）
    await page.click('#saveDraft')  // 默认保存草稿，不直接提交
    await page.waitForSelector('.success-message', { timeout: 10000 })

    return {
      success: true,
      message: 'ERP 发票录入成功（草稿）',
      screenshot: screenshot.toString('base64'),
      draftId: await page.textContent('#draftId')
    }

  } catch (error) {
    const screenshot = await page.screenshot()
    return {
      success: false,
      message: `填写失败: ${error.message}`,
      screenshot: screenshot.toString('base64')
    }
  }
}
```

---

### 3.5 本地数据库设计

```typescript
// src/main/db/schema.ts

export const SCHEMA = `
  -- 发票主表
  CREATE TABLE IF NOT EXISTS invoices (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    invoice_code    TEXT NOT NULL,
    invoice_number  TEXT NOT NULL,
    invoice_date    TEXT,
    invoice_type    TEXT,
    buyer_name      TEXT,
    buyer_tax_id    TEXT,
    seller_name     TEXT,
    seller_tax_id   TEXT,
    total_amount    REAL DEFAULT 0,
    tax_amount      REAL DEFAULT 0,
    total_with_tax  REAL DEFAULT 0,
    check_code      TEXT,
    ocr_source      TEXT DEFAULT 'glm',       -- glm / paddle
    ocr_confidence  REAL DEFAULT 0,
    ocr_raw_json    TEXT,                      -- 原始 OCR 结果备份
    image_path      TEXT,                      -- 原始图片路径
    status          TEXT DEFAULT 'recognized', -- recognized / validated / submitted / approved / rejected
    erp_draft_id    TEXT,                      -- ERP 草稿编号
    submit_time     TEXT,
    created_at      TEXT DEFAULT (datetime('now','localtime')),
    updated_at      TEXT DEFAULT (datetime('now','localtime')),
    UNIQUE(invoice_code, invoice_number)       -- 防重复
  );

  -- 发票明细行
  CREATE TABLE IF NOT EXISTS invoice_items (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    invoice_id      INTEGER NOT NULL,
    item_name       TEXT,
    specification   TEXT,
    unit            TEXT,
    quantity        REAL,
    unit_price      REAL,
    amount          REAL,
    tax_rate        TEXT,
    tax             REAL,
    FOREIGN KEY (invoice_id) REFERENCES invoices(id)
  );

  -- 操作日志（审计追踪）
  CREATE TABLE IF NOT EXISTS operation_logs (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    invoice_id      INTEGER,
    action          TEXT NOT NULL,  -- scan / validate / fill_erp / submit / approve
    target_system   TEXT,           -- erp_sap / reimburse / tax_platform
    result          TEXT,           -- success / fail
    detail          TEXT,
    screenshot_path TEXT,
    operator        TEXT DEFAULT 'system',
    created_at      TEXT DEFAULT (datetime('now','localtime'))
  );

  -- 系统凭据（加密存储）